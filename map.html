<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Bulgaria map</title>
    <script type="text/javascript" src="js/d3.js"></script>
    <style type="text/css">
        /* No style rules here yet */

        .municipality {
            opacity:0;
            visibility: hidden;
            transition: opacity .3s ease-out;
        }

        .municipality.show {
            opacity:1;
            visibility:visible;
        }
    </style>
</head>

<body>
    <div id="map-container" style="background:rgba(239,235,222,.85); width:900px;">
    </div>
    <script type="text/javascript">
        var width = 900;
        var height = 600;
        var center = null;
        var projection = null;

        var vis = d3.select("#map-container").append("svg")
            .attr("width", width).attr("height", height).attr('viewBox', '36 0 900 600');

        d3.json("geojson/provinces.json", function(json) {
            // create a first guess for the projection
            center = d3.geo.centroid(json)
            var scale = 120;
            var offset = [width / 2, height / 2];
            projection = d3.geo.mercator().scale(scale).center(
                    center)
                .translate(offset);

            // create the path
            var path = d3.geo.path().projection(projection);

            // using the path determine the bounds of the current map and use 
            //  these to determine better values for the scale and translation
            var bounds = path.bounds(json);
            var hscale = scale * width / (bounds[1][0] - bounds[0][0]);
            var vscale = scale * height / (bounds[1][1] - bounds[0][1]);
            var scale = (hscale < vscale) ? hscale : vscale;
            var offset = [width - (bounds[0][0] + bounds[1][0]) / 2,
                height - (bounds[0][1] + bounds[1][1]) / 2
            ];

            // new projection
            projection = d3.geo.mercator().center(center)
                .scale(scale).translate(offset);
            path = path.projection(projection);

            vis.selectAll("path")
                .data(json.features).enter()
                .append('g')
                .attr('id', function(d){ 
                    return d.properties.nuts3; 
                })
                .on('click', function(d) {
                    d3.selectAll('.municipality.show')
                        .classed('show', false)
                    
                    d3.selectAll('.nuts-' + d.properties.nuts3)
                        .attr('class', 'municipality show nuts-' + d.properties.nuts3);
                })
                .attr('class', 'province')
                .append(
                    "path")
                .attr("d", path)
                .style("stroke-width", "1")
                .style("stroke", "#7c9944")
                .attr('fill', 'rgba(255,255,255,.45)');

            
            d3.json("geojson/places.json", function(json) {
                json.forEach(function(place) {
                    var geo = place.geo.split(',');
                    var placeGroup = vis.append('g')
                    placeGroup.attr('id', place.municipality_code);    
                    placeGroup
                        .append('circle')
                        .attr("r",5)
                        .attr("transform", function() {
                            return "translate(" + projection([parseFloat(geo[0]), parseFloat(geo[1])]) + ")";
                        }); 
                    placeGroup
                        .append('text')
                        .text(place.name)
                        .attr('x', function() {return -this.getBBox().width/2; })
                        .attr('y', function() {return -this.getBBox().height/2; })
                        .attr("transform", function() {
                            var x = parseFloat(geo[0]);
                            var y = parseFloat(geo[1]);
                            console.log(x,y);
                            return "translate(" + projection([x,y]) + ")";
                        }); 
                });
            });
        });


         d3.json("geojson/municipalities.json", function(json) {
            // create a first guess for the projection
            var center = d3.geo.centroid(json)
            var scale = 120;
            var offset = [width / 2, height / 2];
            var projection = d3.geo.mercator().scale(scale).center(
                    center)
                .translate(offset);

            // create the path
            var path = d3.geo.path().projection(projection);

            // using the path determine the bounds of the current map and use 
            //  these to determine better values for the scale and translation
            var bounds = path.bounds(json);
            var hscale = scale * width / (bounds[1][0] - bounds[0][0]);
            var vscale = scale * height / (bounds[1][1] - bounds[0][1]);
            var scale = (hscale < vscale) ? hscale : vscale;
            var offset = [width - (bounds[0][0] + bounds[1][0]) / 2,
                height - (bounds[0][1] + bounds[1][1]) / 2
            ];

            // new projection
            projection = d3.geo.mercator().center(center)
                .scale(scale).translate(offset);
            path = path.projection(projection);

            vis.selectAll("path").data(json.features).enter()
                .append('g')
                .attr('id', function(d){
                    return d.properties.nut4; 
                })
                .attr('class', function(d) {
                    return 'municipality nuts-' + d.properties.nuts3; 
                })
                .append(
                    "path")
                .attr("d", path)
                .style("stroke-width", "1")
                .style("stroke", "#7c9944")
                .attr('fill', 'rgba(255,255,255,.45)');
        });



    </script>
</body>

</html>
